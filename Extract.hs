module Extract where

import Data.Maybe
import RTree (RTree(..))
import UDConcepts (
    UDTree, Label, UDData, UDWord, POS,
    udFORM, udLEMMA, udUPOS, udXPOS, udDEPREL, udFEATS, 
    udTree2sentence, udWordLines, prt
    )
import UDPatterns (UDPattern(..))
-- TODO: rm if hasError etc. change
import ConceptAlignment(
    Alignment, AlignedTrees(..), 
    linearize
    ) 

-- TODO: rework & expand

-- | TODO: Top-level pattern matching function used in the main
extract = undefined

-- | Check if an alignment contains an error, of any kind
hasError :: Alignment -> Bool 
hasError (AT (t,u), _) = linearize t /= linearize u

-- | Check if an alignment contains a grammatical error 
hasGrammError :: Alignment -> Bool
hasGrammError (AT (t,u), _) = map grammFields wt /= map grammFields wu
  where
    wt = udWordLines $ udTree2sentence t
    wu = udWordLines $ udTree2sentence u
    
    -- get fields that signal grammar errors. Word order errors are
    -- captured when comparing the full lists and I hope it's not too
    -- bad that I am ignoring udHEAD
    -- known issues: 
    -- - some lexical errors are treated as grammatical due to POS
    --   tag (AUX vs. VERB) and deprel (cop) differences 
    grammFields :: UDWord -> (POS,String,[UDData],Label)
    grammFields w = (udUPOS w, udXPOS w, udFEATS w, udDEPREL w)

-- | Convert a UD tree into a UD pattern (HST)
-- maybe this belongs in gf-ud though
udTree2udPattern :: UDTree -> UDPattern
udTree2udPattern (RTree n []) = AND [
  FORM (udFORM n), 
  LEMMA (udLEMMA n), 
  POS (udUPOS n), 
  -- XPOS (udXPOS n), -- can be added after updating gf-ud, I think
  FEATS (prt $ udFEATS n), 
  DEPREL (udDEPREL n)
  -- no MISC cause I dunno what the second string is supposed to be:
  -- https://github.com/GrammaticalFramework/gf-ud/blob/f2705537347b417e37f1ccd156708bf066e790d6/UDPatterns.hs#L49
  ]
udTree2udPattern (RTree n ts) = 
  TREE (udTree2udPattern (RTree n [])) (map udTree2udPattern ts)

type ColumnName = String -- name of a UD column

-- | Discard certains UD columns from an HST patter
-- NOTE: only works for patterns like those generated by udTree2udPattern
simplifyUDPattern :: UDPattern -> [ColumnName] -> UDPattern
simplifyUDPattern (AND vals) cols = AND $ 
  -- there must be a better way that can be applied repeatedly but I'm tired
  catMaybes [
    if "FORM" `elem` cols then Just $ vals !! 0 else Nothing,
    if "LEMMA" `elem` cols then Just $ vals !! 1 else Nothing,
    if "POS" `elem` cols then Just $ vals !! 2 else Nothing,
    if "FEATS" `elem` cols then Just $ vals !! 3 else Nothing,
    if "DEPREL" `elem` cols then Just $ vals !! 4 else Nothing
  ]
simplifyUDPattern (TREE n ts) cols = 
  TREE (simplifyUDPattern n cols) (map (`simplifyUDPattern` cols) ts) 
simplifyUDPattern _ _ = undefined 