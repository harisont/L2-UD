module Errors where

import Data.List
import Data.Maybe
import RTree
import UDConcepts
import UDPatterns
import Align
import Utils

type Error = (UDTree,UDTree)
type ErrorPattern = (UDPattern,UDPattern)

linearizeError :: Error -> String
linearizeError = linearizeAlignment

-- | Convert a UD tree into a UD pattern (HST)
-- maybe this belongs in gf-ud though
udTree2udPattern :: UDTree -> UDPattern
udTree2udPattern (RTree n []) = AND [
  FORM (udFORM n), 
  LEMMA (udLEMMA n), 
  POS (udUPOS n), 
  XPOS (udXPOS n),
  FEATS (prt $ udFEATS n), 
  DEPREL (udDEPREL n)
  -- no MISC cause I dunno what the second string is supposed to be:
  -- https://github.com/GrammaticalFramework/gf-ud/blob/f2705537347b417e37f1ccd156708bf066e790d6/UDPatterns.hs#L49
  ]
udTree2udPattern (RTree n ts) = AND [
  TREE (udTree2udPattern (RTree n [])) (map udTree2udPattern ts),
  SEQUENCE $ map udTree2udPattern ns
  ]
    where ns = sortBy (\n m -> compare (rootID n) (rootID m)) (RTree n []:ts)

-- | Shorthand to convert errors to error patterns
error2Pattern :: Error -> ErrorPattern
error2Pattern (e1,e2) = (udTree2udPattern e1,udTree2udPattern e2)

type ColumnName = String -- name of a UD column

morphosynColumns :: [ColumnName]
morphosynColumns = ["POS", "XPOS", "FEATS", "DEPREL"]

-- | Discard UD columns from an HST patter excepts those explicitly listed
-- NOTE: only works for patterns like those generated by udTree2udPattern
simplifyUDPattern :: UDPattern -> [ColumnName] -> UDPattern
simplifyUDPattern (AND [TREE n ts, SEQUENCE ns]) cols = AND [
  simplifyUDPattern (TREE n ts) cols, 
  simplifyUDPattern (SEQUENCE ns) cols]
simplifyUDPattern (AND vals) cols = AND $ 
  -- there must be a better way that can be applied repeatedly but I'm tired
  catMaybes [
    if "FORM" `elem` cols then Just $ vals !! 0 else Nothing,
    if "LEMMA" `elem` cols then Just $ vals !! 1 else Nothing,
    if "POS" `elem` cols then Just $ vals !! 2 else Nothing,
    if "XPOS" `elem` cols then Just $ vals !! 3 else Nothing,
    if "FEATS" `elem` cols then Just $ vals !! 4 else Nothing,
    if "DEPREL" `elem` cols then Just $ vals !! 5 else Nothing
  ]
simplifyUDPattern (TREE n ts) cols = 
  TREE (simplifyUDPattern n cols) (map (`simplifyUDPattern` cols) ts)
simplifyUDPattern (SEQUENCE ns) cols = 
  SEQUENCE (map (`simplifyUDPattern` cols) ns) 
simplifyUDPattern p _ = p 

-- | Shorthand for getting the morphosyntactic (POS + XPOS + FEATS + DEPREL)  
-- UD pattern corresponding to a "full" UD pattern
morphosynUDPattern :: UDPattern -> UDPattern
morphosynUDPattern = (flip simplifyUDPattern) morphosynColumns